Este algoritmo eval√∫a todas las posibles combinaciones de subarrays utilizando, cada subarray podemos representarlo como un punto de inicio y un punto de fin.
\begin{lstlisting}
public static int MaxSubarraySum(int[] array)
{
    int maxSum = 0;

    for (int i = 0; i < array.Length; i++)
    {
        for (int j = i; j < array.Length; j++)
        {
            int currentSum = 0;

            for (int k = i; k <= j; k++)
            {
                currentSum += array[k];
            }

            if (currentSum > maxSum)
                maxSum = currentSum;
        }
    }

    return maxSum;
}
\end{lstlisting}

Podemos eliminar el tercer ciclo manteniendo un acumulador (currentSum) que suma los elementos del subarray actual mientras recorre el array.

\begin{lstlisting}
public static int MaxSubarraySum(int[] array)
{
    int maxSum = 0;

    for (int i = 0; i < array.Length; i++)
    {
        int currentSum = 0;

        for (int j = i; j < array.Length; j++)
        {
            currentSum += array[j];

            if (currentSum > maxSum)
                maxSum = currentSum;
        }
    }

    return maxSum;
}
\end{lstlisting}